<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 32f40340-4899-4d4c-a388-e3893ccab58f (2026-01-16 22:53Z) -->

# Brightness data origin (2026-01-16 22:53Z)

_**User (2026-01-16 11:58Z)**_

@code block (1-24) where does the {{ brightness }} in the data come from

---

_**Agent (model default, mode Ask)**_



---


Checking how template lights handle `set_level` and where `brightness` comes from in this codebase.


---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** ‚Ä¢ Searched codebase "template light set_level brightness parameter" ‚Ä¢ **15** results</summary>
            
| File | Lines |
|------|-------|
| `hass-generator/src/generators/dashboard/templates/bubble/renderer.js` | L196-292 |
| `hass-generator/src/generators/dashboard/templates/bubble-views/renderer.js` | L316-406 |
| `hass-config/generator.config.js` | L68 |
| `hass-generator/src/generators/dashboard/data.js` | L195-255 |
| `hass-generator/templates/types/config.d.ts.template` | L66 |
| `hass-config/scenes/generated.yaml` | L135-215 |
| `hass-generator/src/generators/area-package.js` | L36-138 |
| `hass-config/groups.yaml` | L38 |
| `hass-config/scenes/generated.yaml` | L55-140 |
| `hass-config/scenes.yaml` | L589-671 |
| `hass-config/scenes.yaml` | L1039-1081 |
| `hass-config/knx/knx.yaml` | L104 |
| `hass-config/scenes/generated.yaml` | L210-289 |
| `hass-config/scenes/generated.yaml` | L60 |
| `hass-config/scenes.yaml` | L665-722 |

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** ‚Ä¢ Grep for "set_level|brightness" in "/Users/sharonfrenkel/Dev/hass-generator" ‚Ä¢ 28 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `./CONFIG_OPTIONS.md` | `- **Value**: The companion bulb entity ID (controls brightness)` | L101 |
| `./CONFIG_OPTIONS.md` | `// UI shows switch.mb_soc with light.mb_soc_bulb's brightness slider` | L162 |
| `./tests/fixtures/raw-ha-data.json` | `"supported_color_modes": ["brightness"],` | L8 |
| `./tests/fixtures/raw-ha-data.json` | `"brightness": 255` | L9 |
| `./tests/fixtures/raw-ha-data.json` | `"supported_color_modes": ["brightness"]` | L25 |
| `./tests/fixtures/raw-ha-data.json` | `"supported_color_modes": ["brightness"]` | L55 |
| `./tests/fixtures/minimal-inventory.json` | `"attributes": \{ "supported_color_modes": ["brightness"], "brightness": 255 \},` | L25 |
| `./tests/fixtures/minimal-inventory.json` | `"attributes": \{ "supported_color_modes": ["brightness"] \},` | L53 |
| `./tests/fixtures/minimal-inventory.json` | `"attributes": \{ "supported_color_modes": ["brightness"] \},` | L179 |
| `./tests/fixtures/minimal-inventory.json` | `"attributes": \{ "supported_color_modes": ["brightness"] \},` | L207 |
| `./tests/fixtures/minimal-inventory.json` | `"attributes": \{ "supported_color_modes": ["brightness"] \},` | L249 |
| `./tests/unit/bubble-renderer.test.js` | `// Find a dimmable light (light.lr_ceiling has brightness mode)` | L181 |
| `./tests/unit/bubble-renderer.test.js` | `// Find ceiling light (brightness only, no advanced)` | L238 |
| `./tests/unit/dashboard-data.test.js` | `test('actuator with companion has brightness_entity pointing to bulb', () => \{` | L114 |
| `./tests/unit/dashboard-data.test.js` | `expect(actuator.brightness_entity).toBe('light.mb_soc_bulb')` | L128 |
| `./tests/unit/dashboard-data.test.js` | `test('light with brightness mode is dimmable', () => \{` | L135 |
| `./tests/unit/dashboard-data.test.js` | `test('light with brightness only does not have has_advanced_controls', () => \{` | L174 |
| `./tests/unit/transform.test.js` | `expect(ceiling.attributes.supported_color_modes).toContain('brightness')` | L134 |
| `./src/types/config.d.ts` | `* The actuator controls power, the bulb controls brightness.` | L23 |
| `./templates/types/config.d.ts.template` | `* The actuator controls power, the bulb controls brightness.` | L24 |
| `./src/generators/dashboard/templates/bubble/renderer.js` | `const \{ dimmable, brightness_entity, toggle_entity, has_advanced_controls \} = light` | L209 |
| `./src/generators/dashboard/templates/bubble/renderer.js` | `entity: brightness_entity,` | L215 |
| `./src/generators/dashboard/templates/bubble/renderer.js` | `const toggleAction = brightness_entity !== toggle_entity` | L221 |
| `./src/generators/dashboard/templates/bubble-views/renderer.js` | `const \{ dimmable, brightness_entity, toggle_entity, has_advanced_controls \} = light` | L329 |
| `./src/generators/dashboard/templates/bubble-views/renderer.js` | `entity: brightness_entity,` | L335 |
| `./src/generators/dashboard/templates/bubble-views/renderer.js` | `const toggleAction = brightness_entity !== toggle_entity` | L340 |
| `./src/generators/dashboard/data.js` | `result.push(\{ entity_id: entityId, name: null, dimmable: false, brightness_entity: entityId, toggle_entity: entityId, has_advanced_controls: false \})` | L225 |
| `./src/generators/dashboard/data.js` | `brightness_entity: companionBulb \|\| entity.entity_id,` | L252 |


</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** ‚Ä¢ Grep for "template.*light|set_level" in "/Users/sharonfrenkel/Dev/hass-config" ‚Ä¢ 0 matches</summary>

Output mode: content


_No matches found_

</details>
</tool-use>

---



---


In Home Assistant template lights, `{{ brightness }}` is automatically provided by Home Assistant when `set_level` is called.

**How it works:**
- When a service like `light.turn_on` is called on a template light with a brightness value, Home Assistant sets the `brightness` variable in the template context.
- In your `set_level` action, `{{ brightness }}` is that value passed to the service call.
- Example: if `light.turn_on` is called with `brightness: 128`, then `{{ brightness }}` is `128` in that template evaluation.

This is standard template light behavior in Home Assistant‚Äî`brightness` is a predefined variable available in `set_level` actions, similar to how `transition` or other parameters are provided when the corresponding service call includes them.

The template light documentation covers this: `set_level` receives `brightness` as a template variable when the light is set to a specific brightness level.

---

_**User (2026-01-16 11:58Z)**_

how is light.turn_on is called with brightness: 128

---

_**Agent (model default, mode Ask)**_



---


Searching for how brightness is passed to template lights and how `light.turn_on` is invoked with brightness.


---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** ‚Ä¢ Searched codebase "light turn_on brightness service call" ‚Ä¢ **15** results</summary>
            
| File | Lines |
|------|-------|
| `hass-generator/src/generators/dashboard/templates/bubble/renderer.js` | L196-292 |
| `hass-generator/src/generators/dashboard/templates/bubble-views/renderer.js` | L316-406 |
| `hass-config/automations.yaml` | L106 |
| `hass-config/automations.yaml` | L281-380 |
| `hass-config/automations.yaml` | L377-458 |
| `hass-config/automations.yaml` | L195-287 |
| `hass-config/blueprints/automation/homeassistant/motion_light.yaml` | L56 |
| `hass-config/automations.yaml` | L450-544 |
| `hass-config/automations.yaml` | L99-201 |
| `hass-config/lovelace/main.yaml` | L697-751 |
| `hass-config/lovelace/views-en.yaml` | L2359-2425 |
| `hass-config/scenes.yaml` | L665-722 |
| `hass-config/lovelace/main.yaml` | L1159-1206 |
| `hass-config/knx/knx.yaml` | L210-329 |
| `hass-config/lovelace/main.yaml` | L1664-1715 |

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** ‚Ä¢ Searched codebase "template light set_level how brightness parameter passed" ‚Ä¢ **15** results</summary>
            
| File | Lines |
|------|-------|
| `hass-generator/src/generators/dashboard/templates/bubble/renderer.js` | L196-292 |
| `hass-generator/src/generators/dashboard/templates/bubble-views/renderer.js` | L316-406 |
| `hass-generator/src/generators/dashboard/data.js` | L195-255 |
| `hass-generator/src/generators/area-package.js` | L36-138 |
| `hass-config/scenes/generated.yaml` | L135-215 |
| `hass-config/scenes/generated.yaml` | L55-140 |
| `hass-config/scenes/generated.yaml` | L210-289 |
| `hass-generator/src/generators/scene-template-package.js` | L54-110 |
| `hass-generator/src/generators/dashboard/index.js` | L34 |
| `hass-generator/src/generators/scene-template-package.js` | L7-110 |
| `hass-config/tools/hass-data-generator/src/generators/area-package.js` | L47-161 |
| `hass-config/scenes/generated.yaml` | L60 |
| `hass-config/groups.yaml` | L38 |
| `hass-config/knx/knx.yaml` | L104 |
| `hass-generator/src/generators/scene-template-package.js` | L85 |

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** ‚Ä¢ Read file: /Users/sharonfrenkel/Dev/hass-config/generator.config.js</summary>

</details>
</tool-use>

---



---


Searching for examples of `light.turn_on` calls with brightness in the codebase.


---

<tool-use data-tool-type="search" data-tool-name="web_search">
<details>
            <summary>Tool use: **web_search** ‚Ä¢ Searched web `Home Assistant template light set_level brightness parameter how called` ‚Ä¢ **1** results</summary>
        
| Title | URL | Chunk |
|-------|-----|-------|
| Web Search Results |  | In Home Assistant‚Äôs template light integration, when you see `\{{ brightness \}}` in a `set_level` (or similar) action, that `brightness` is a variable provided by Home Assistant automatically ‚Äî it comes from the parameters in the service call like `light.turn_on`. Here‚Äôs exactly where it comes from and how `light.turn_on` ends up supplying it.<br/><br/>---<br/><br/>## How `brightness` gets defined<br/><br/>- The **template light platform** allows you to define custom behavior for various ‚Äúmodes‚Äù or ‚Äúcommands‚Äù of a light via templates. One of these is `set_level`, which is specifically for brightness-only changes. ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai))  <br/>- According to the docs, Home Assistant will call the `set_level` action when the service call is `light.turn_on` with **only** a `brightness` parameter (and optionally `transition`). In that situation, Home Assistant exposes `brightness` as a template variable. ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai))<br/><br/>---<br/><br/>## When `light.turn_on` uses `brightness`<br/><br/>- If you call `light.turn_on` (via YAML automation, script, GUI, etc.) and include `brightness` in the `data:` section, Home Assistant receives that value as part of the service call. For example:<br/><br/>  ```yaml<br/>  service: light.turn_on<br/>  target:<br/>    entity_id: light.my_light<br/>  data:<br/>    brightness: 128<br/>  ```<br/><br/>- Since you're calling with `brightness` only, and no color or other mode-changing attribute (aside from maybe `transition`), the template light integration interprets that as a brightness-only command, triggering the `set_level` template. That template is passed the `brightness` value you provided. ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai))<br/><br/>---<br/><br/>## Summary: "Where does `\{{ brightness \}}` come from?"<br/><br/>Putting it all together:<br/><br/>1. You issue a `light.turn_on` service call with `\{ brightness: SOME_VALUE \}`.<br/>2. If that call has only brightness (and optionally transition), the template light platform uses the `set_level` action for that call.<br/>3. By design, Home Assistant makes `brightness` available as a variable in the template context for `set_level`. That is where `\{{ brightness \}}` is coming from.<br/><br/>---<br/><br/>If you want, I can walk you through an example of what the YAML for a full template light definition looks like with `set_level`, so you can see where `\{{ brightness \}}` is used in practice. |

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** ‚Ä¢ Grep for "light\.turn_on|brightness_pct|brightness:" in "/Users/sharonfrenkel/Dev/hass-config" ‚Ä¢ 12 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `./scenes.yaml` | `brightness: 112` | L651 |
| `./scenes.yaml` | `brightness: 222` | L680 |
| `./scenes.yaml` | `brightness: null` | L799 |
| `./scenes.yaml` | `brightness: 255` | L903 |
| `./scenes.yaml` | `brightness: 255` | L1007 |
| `./scenes.yaml` | `brightness: 3` | L1061 |
| `./automations.yaml` | `- action: light.turn_on` | L179 |
| `./automations.yaml` | `- action: light.turn_on` | L227 |
| `./automations.yaml` | `- action: light.turn_on` | L337 |
| `./automations.yaml` | `- action: light.turn_on` | L449 |
| `./automations.yaml` | `- action: light.turn_on` | L513 |
| `./blueprints/automation/homeassistant/motion_light.yaml` | `service: light.turn_on` | L44 |


</details>
</tool-use>

---



---





---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** ‚Ä¢ Read file: /Users/sharonfrenkel/Dev/hass-config/automations.yaml</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** ‚Ä¢ Read file: /Users/sharonfrenkel/Dev/hass-config/scenes.yaml</summary>

</details>
</tool-use>

---



---


üìó How `light.turn_on` with `brightness` triggers `set_level`:

**The flow:**

1. Any caller invokes `light.turn_on` on your template light with `brightness`:
   - Lovelace UI slider (user drags brightness)
   - Automation/script service call
   - Manual service call from Developer Tools
   - Another integration or component

   Example service call:
   ```yaml
   service: light.turn_on
   target:
     entity_id: light.living_room_main_light
   data:
     brightness: 128  # This is where brightness comes from
   ```

2. Home Assistant detects that the call includes `brightness` (and optionally `transition`), but no color/color_temp changes.

3. Home Assistant triggers the `set_level` action in your template light configuration (not `turn_on`).

4. Home Assistant makes `brightness` available as a template variable in the `set_level` context, so `{{ brightness }}` resolves to `128` (or whatever value was passed).

**In your template:**
```yaml
set_level:
  - service: switch.turn_on
    target:
      entity_id: switch.knx_lr_light
  - delay: 0.3
  - service: light.turn_on
    target:
      entity_id: light.lr_smart_bulb
    data:
      brightness: "{{ brightness }}"  # ‚Üê This is 128 from the original service call
```

The `{{ brightness }}` variable is provided by Home Assistant from the original `light.turn_on` service call parameters. It's not defined in your template; it's injected by Home Assistant when executing `set_level`.

**Common sources of `light.turn_on` with brightness:**
- Lovelace light card brightness slider
- Scene activation (if the scene includes brightness)
- Automation/script service calls
- Voice assistants
- Mobile app controls

All of these ultimately call `light.turn_on` with a `brightness` value, which triggers your `set_level` action.

---

_**User (2026-01-16 11:58Z)**_

what other params can hass make available in the template context?

---

_**Agent (model default, mode Ask)**_



---


Searching Home Assistant documentation for template variables available in template light contexts.


---

<tool-use data-tool-type="search" data-tool-name="web_search">
<details>
            <summary>Tool use: **web_search** ‚Ä¢ Searched web `Home Assistant template light set_level available template variables brightness transition color_temp rgb_color` ‚Ä¢ **1** results</summary>
        
| Title | URL | Chunk |
|-------|-----|-------|
| Web Search Results |  | Here are the variables that Home Assistant makes available in the template context for template-light actions like `set_level`, `set_hs`, `set_rgb`, etc. Each action has specific variables, depending on what kind of light command is being issued. ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai))<br/><br/>---<br/><br/>## Available Variables by Action<br/><br/>\| Action \| Variables Provided \|<br/>\|---\|---\|<br/>\| **turn_on** \| `brightness` (if brightness is included), `transition` (if provided) ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai)) \|<br/>\| **turn_off** \| `transition` (if provided) ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai)) \|<br/>\| **set_level** (brightness only) \| `brightness`, optionally `transition` ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai)) \|<br/>\| **set_temperature** \| `color_temp`, optionally `brightness` and/or `transition` ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai)) \|<br/>\| **set_hs** \| `hs` (tuple), `h`, `s` ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai)) \|<br/>\| **set_rgb** \| `rgb` (tuple), `r`, `g`, `b` ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai)) \|<br/>\| **set_rgbw** \| `rgbw` (tuple), also `rgb` and `r`, `g`, `b`, `w` components ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai)) \|<br/>\| **set_rgbww** \| `rgbww` (tuple), and `rgb`, `r`, `g`, `b`, `cw`, `ww` ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai)) \|<br/>\| **set_effect** \| `effect`, optionally `brightness` and/or `transition` ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai)) \|<br/><br/>---<br/><br/>## Additional Context Variables<br/><br/>- For **template entities** (including template lights), there‚Äôs a special variable named `this` that refers to the current state object of the template entity (including its attributes). This is useful if you want to include logic based on the current state or attribute values. ([docs.ncnynl.com](https://docs.ncnynl.com/en/home-assistant/integrations/light.template/?utm_source=openai))<br/>  <br/>- For **trigger-based template entities**, you also have access to `trigger` data inside templates and actions. ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai))<br/><br/>---<br/><br/>If you tell me the specific template-light action you‚Äôre working with (e.g. `set_rgbww` or `set_temperature`), I can show you exactly which variables will be available in *your* context. |

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="web_search">
<details>
            <summary>Tool use: **web_search** ‚Ä¢ Searched web `Home Assistant template light integration all template variables turn_on set_level set_color_mode` ‚Ä¢ **1** results</summary>
        
| Title | URL | Chunk |
|-------|-----|-------|
| Web Search Results |  | Here‚Äôs a breakdown of what variables Home Assistant makes available to the templates/actions in a `light.template` configuration, especially for things like `set_level`, `set_temperature`, `set_hs`, etc. Most of what follows comes from the official documentation. ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai))<br/><br/>---<br/><br/>### Available Context Variables for Template Light Actions<br/><br/>Depending on which type of command or action is being executed (brightness-only, color temperature, color changes, etc.), different variables are populated in the template context. Here are the main ones:<br/><br/>\| Action \| Common Variables Provided \|<br/>\|---\|---\|<br/>\| `turn_on` \| `brightness` (0‚Äì255), `transition` (duration in seconds or whatever‚Äôs passed), optionally `color_temp`, `hs`, `rgb`, `effect` depending on what is passed in the service call. ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai)) \|<br/>\| `turn_off` \| `transition` if provided in the turn_off call. ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai)) \|<br/>\| `set_level` (brightness-only commands) \| `brightness` always, and `transition` if a transition is also passed. ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai)) \|<br/>\| `set_temperature` \| `color_temp` is always available. Also, `brightness` and `transition` if those are part of the `turn_on` call. ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai)) \|<br/>\| `set_hs` \| Provides `hs` (tuple: hue and saturation), and separately `h` and `s` variables. Also can have `brightness` and/or `transition` if those were included in the caller. ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai)) \|<br/>\| `set_rgb`, `set_rgbw`, `set_rgbww` \| For `set_rgb`: `rgb` tuple, plus `r`, `g`, `b`; for `rgbw`/`rgbww` modes: includes extra channels like `w` (white), `cw` (cold white), `ww` (warm white) as appropriate. Plus `brightness`, `transition` where applicable. ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai)) \|<br/><br/>---<br/><br/>### Additional Details & Constraints<br/><br/>- If the service call includes **only** a brightness value (and optionally transition), then the `set_level` action is used. If that brightness is passed alongside other parameters like color or color_temp, a more specific action may be used instead. ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai))  <br/>- For example, a `light.turn_on` with `brightness` + `color_temp` uses the `set_temperature` action rather than `set_level`. ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai))  <br/>- The `transition` parameter isn't its own action; it's passed into whichever action is appropriate (turn_on, set_level, set_temperature, etc.). ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai))  <br/>- Templates also support `this` in some contexts, which refers to the current state object of the template light entity itself. It can be useful to inspect the light‚Äôs state/attributes in your templates. ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai))  <br/><br/>---<br/><br/>If you want, I can give you a full list of *all* variables (including obscure ones), or examples of using them in YAML. |

</details>
</tool-use>

---



---


üìó Template variables available in template light actions, by action:

## Variables by Action

**`set_level` (brightness-only)**
- `brightness` - 0-255
- `transition` - transition duration (if provided)

**`set_temperature` (color temperature)**
- `color_temp` - color temperature value
- `brightness` - 0-255 (if provided)
- `transition` - transition duration (if provided)

**`set_hs` (hue/saturation)**
- `hs` - tuple `[h, s]`
- `h` - hue (0-360)
- `s` - saturation (0-100)
- `brightness` - 0-255 (if provided)
- `transition` - transition duration (if provided)

**`set_rgb`**
- `rgb` - tuple `[r, g, b]`
- `r` - red (0-255)
- `g` - green (0-255)
- `b` - blue (0-255)
- `brightness` - 0-255 (if provided)
- `transition` - transition duration (if provided)

**`set_rgbw`**
- `rgbw` - tuple `[r, g, b, w]`
- `rgb` - tuple `[r, g, b]`
- `r`, `g`, `b`, `w` - individual components (0-255)
- `brightness` - 0-255 (if provided)
- `transition` - transition duration (if provided)

**`set_rgbww`**
- `rgbww` - tuple `[r, g, b, cw, ww]`
- `rgb` - tuple `[r, g, b]`
- `r`, `g`, `b`, `cw`, `ww` - individual components (0-255)
- `brightness` - 0-255 (if provided)
- `transition` - transition duration (if provided)

**`set_effect`**
- `effect` - effect name/string
- `brightness` - 0-255 (if provided)
- `transition` - transition duration (if provided)

**`turn_on` (generic)**
- Any parameters from the service call (e.g., `brightness`, `color_temp`, `hs`, `rgb`, `effect`, `transition`)
- Which action runs depends on which parameters are provided

**`turn_off`**
- `transition` - transition duration (if provided)

## Additional Context Variables

- `this` - refers to the current state object of the template light entity (useful for checking current state/attributes)
- Standard Home Assistant template variables (`states`, `state_attr`, etc.)

Example using multiple variables:

```yaml
set_temperature:
  - service: light.turn_on
    target:
      entity_id: light.my_bulb
    data:
      color_temp: "{{ color_temp }}"
      brightness: "{{ brightness }}"
      transition: "{{ transition }}"
```

Variables are only available when the corresponding action is triggered and the parameter was included in the service call.

---

_**User (2026-01-16 11:58Z)**_

could i make the template i provided only handle set_level, not on or off?

---

_**Agent (model default, mode Ask)**_



---


Searching Home Assistant documentation to confirm whether template lights can use only `set_level` without `turn_on` or `turn_off`.


---

<tool-use data-tool-type="search" data-tool-name="web_search">
<details>
            <summary>Tool use: **web_search** ‚Ä¢ Searched web `Home Assistant template light set_level only without turn_on turn_off required` ‚Ä¢ **1** results</summary>
        
| Title | URL | Chunk |
|-------|-----|-------|
| Web Search Results |  | Yes ‚Äî you *can* make a Home Assistant template light only handle `set_level` (brightness changes) and ignore or disable the `turn_on` / `turn_off` actions. Here‚Äôs how template lights work and how you could configure one to only support brightness (`set_level`), not full on/off control.<br/><br/>---<br/><br/>## How Template Lights Handle Actions<br/><br/>The [Home Assistant template light integration documentation](https://www.home-assistant.io/integrations/light.template/) says:<br/><br/>- `turn_on` and `turn_off` actions are **required** for template lights. They define what happens when the light is turned on or off. ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai))  <br/>- `set_level` is *optional*. It defines what happens when the light is given only a brightness command (i.e. when it's turned on *with only* brightness specified, optionally with `transition`) rather than both brightness *and* other attributes. ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai))  <br/>- If `turn_on` is called *only* with brightness (and optionally `transition`), and `set_level` is defined, then `set_level` action handles that case instead of `turn_on`. ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai))<br/><br/>So the actions flow like:<br/><br/>1. You call `light.turn_on` with just `brightness` (optionally `transition`) ‚Üí **`set_level`** handles it.<br/>2. You call `light.turn_on` with brightness *plus* something else (e.g. color, effect, temperature) ‚Üí `turn_on` handles it.<br/>3. You call `light.turn_off` ‚Üí `turn_off` handles it.  <br/>   <br/>---<br/><br/>## Can You Only Support `set_level` and Disable `turn_on` / `turn_off`?<br/><br/>Officially, **no**: the template light must have `turn_on` and `turn_off` actions defined. If you omit them, Home Assistant configuration will reject the template light as invalid. ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai))<br/><br/>However, you *can* work around this so that effectively, only brightness changes are ‚Äútrusted‚Äù or acted upon, and on/off is either ignored or minimally handled. Here are some options:<br/><br/>---<br/><br/>## Workarounds to Ignore On/Off<br/><br/>### 1. Make `turn_on` / `turn_off` do nothing or minimal<br/><br/>Define `turn_on` and `turn_off` actions, but have them either:<br/><br/>- do nothing except something shallow (e.g. update some helper), or  <br/>- check the incoming context (`brightness`) and *only* perform something if brightness is included (so pure on/off doesn‚Äôt do anything meaningful).<br/><br/>For example:<br/><br/>```yaml<br/>template:<br/>  - light:<br/>      - name: "Brightness Only Light"<br/>        unique_id: brightness_only_light<br/>        value_template: "\{{ state_attr('light.some_other_light', 'brightness')\|int > 0 \}}"<br/>        level_template: "\{{ state_attr('light.some_other_light', 'brightness')\|int \}}"<br/>        # turn_on and turn_off required:<br/>        turn_on:<br/>          # maybe just call light.turn_on, but don‚Äôt allow changing brightness here<br/>          service: light.turn_on<br/>          target:<br/>            entity_id: light.some_other_light<br/>        turn_off:<br/>          # maybe call light.turn_off, or do nothing<br/>          service: light.turn_off<br/>          target:<br/>            entity_id: light.some_other_light<br/>        set_level:<br/>          service: light.turn_on<br/>          target:<br/>            entity_id: light.some_other_light<br/>          data:<br/>            brightness: "\{{ brightness \}}"<br/>```<br/><br/>Then, in practice, UI actions that only change brightness will trigger your `set_level` action. Pure `turn_on` without brightness won‚Äôt change brightness. Probably the UI will still show the brightness slider, but interactions without supplying brightness won‚Äôt do anything unexpected. <br/><br/>### 2. Use `supported_color_modes` / `color_mode` flags<br/><br/>Template lights derive their color mode / supported modes based on what you define in templates like `level_template`, `temperature_template`, `hs_template`, etc.<br/><br/>- If you only define `level_template` (i.e. brightness) and *omit* templates/actions for color, temperature, HS, effects, etc., then the light will be treated as **Brightness-only**. ([developers.home-assistant.io](https://developers.home-assistant.io/docs/core/entity/light?utm_source=openai))  <br/>- If there are no color modes, the UI should only present brightness control (if `set_level` is present) + basic on/off (from `turn_on`/`turn_off`). So while `turn_off`/`turn_on` must exist, the UI might restrict available controls. <br/><br/>### 3. Filter out on/off in UI or automations<br/><br/>You can also suppress visibility of on/off controls via front-end customization or scripts: e.g. use custom card UI, or expose only brightness-controlling automations. But this is more cosmetic; the logic still exists under the hood.<br/><br/>---<br/><br/>## Conclusion<br/><br/>- You **can‚Äôt omit** `turn_on` / `turn_off` entirely ‚Äî they are required for a template light configuration.  <br/>- But you *can* define `set_level` to handle brightness-only commands, and have `turn_on`/`turn_off` either do nothing significant or rely on minimal/no-op logic, so that effectively brightness control is your primary functionality.  <br/>- Also, by not supplying templates/actions for color/temp/etc., you make the light ‚Äúbrightness-only‚Äù from Home Assistant‚Äôs perspective.  <br/><br/>If you want, I can help draft a complete YAML for a template light that behaves exactly like "only brightness, ignore on/off" so it matches your needs. Do you want me to generate that? |

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="web_search">
<details>
            <summary>Tool use: **web_search** ‚Ä¢ Searched web `Home Assistant template light turn_on optional only set_level brightness control` ‚Ä¢ **1** results</summary>
        
| Title | URL | Chunk |
|-------|-----|-------|
| Web Search Results |  | Yes‚Äîyou *can* configure a Home Assistant template light to only handle the `set_level` action and ignore or block `turn_on`/`turn_off` if you want. Here's how it works and what the implications are, based on the official docs and some community insights.  <br/><br/>---<br/><br/>### What the official docs say<br/><br/>From the Home Assistant docs for the `light.template` integration:<br/><br/>- You define *actions* for `turn_on` and `turn_off`, which are required. These actions *may* receive parameters like `brightness` or `transition` when those are part of the service call. ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai))  <br/>- You *can* optionally define a `set_level` action, which is specifically used when only brightness (and optionally transition) is passed in a `light.turn_on` call. If that‚Äôs the case, the `turn_on` action is *not* called‚Äî`set_level` is. ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai))  <br/><br/>---<br/><br/>### Strategy: Only handle brightness<br/><br/>If you want your template light to *only* respond to `set_level` (i.e. brightness changes), and ignore `turn_on` or `turn_off`, here are a couple of ways to achieve that:<br/><br/>#### 1. Make `turn_on` and `turn_off` no-ops (do nothing)<br/><br/>Define `turn_on` and `turn_off` actions that do nothing‚Äîor simply exit early‚Äîso any requests to turn the light on/off are ignored. Meanwhile, implement `set_level` to actually do what you want when brightness is set.<br/><br/>Example:<br/><br/>```yaml<br/>light:<br/>  - platform: template<br/>    lights:<br/>      my_light:<br/>        friendly_name: "Brightness-only Light"<br/>        value_template: "\{{ states('light.real_device') \}}"<br/>        level_template: "\{{ state_attr('light.real_device','brightness') \| int(0) \}}"<br/>        turn_on:<br/>          # do nothing or a no-op service<br/>          service: homeassistant.turn_on<br/>          target:<br/>            entity_id: light.my_light  # basically does nothing<br/>        turn_off:<br/>          # same no-op<br/>          service: homeassistant.turn_off<br/>          target:<br/>            entity_id: light.my_light<br/>        set_level:<br/>          # the actual implementation<br/>          service: light.turn_on<br/>          target:<br/>            entity_id: light.real_device<br/>          data:<br/>            brightness: "\{{ brightness \}}"<br/>```<br/><br/>#### 2. Use conditions/templates inside `turn_on`/`turn_off`<br/><br/>You could conditionally ignore `turn_on`/`turn_off` based on context. For example, only process them if *other* attributes are present, or when brightness is a specific value, etc.<br/><br/>In Jinja templating you could check whether `brightness` or `transition` is defined in the incoming data. If it‚Äôs not, simply return `no_op`. Something like:<br/><br/>```yaml<br/>turn_on:<br/>  - condition: template<br/>    value_template: "\{{ brightness is defined or transition is defined \}}"<br/>  - service: light.turn_on<br/>    target:<br/>      entity_id: light.real_device<br/>    data:<br/>      brightness: "\{{ brightness \}}"<br/>```<br/><br/>Although note: docs say `turn_on` *may* receive `brightness`/`transition` if those are in the call. If only brightness is passed, `set_level` takes over *instead of* `turn_on`. So your logic could effectively be: ‚Äúif brightness is passed, allow; otherwise do nothing.‚Äù ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai))<br/><br/>---<br/><br/>### Important caveats<br/><br/>- The template light definition *requires* that both `turn_on` and `turn_off` actions be present. Even if you intend to ‚Äúignore‚Äù them, they must still be defined. ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai))  <br/>- If you implement `set_level`, that only handles calls where the service gives *only* brightness (and optionally `transition`). If a `turn_on` call comes with other parameters (e.g. color, effect), `turn_on` will still be invoked. So ‚Äúfully ignoring‚Äù `turn_on` might be tricky if other integrations or the UI add extra params.  <br/>- The UI (e.g. sliders or cards) may send `turn_on` with brightness; you can‚Äôt fully control how the frontend or other automations call services unless you control all inputs.<br/><br/>---<br/><br/>If you want, I can draft a YAML example for your specific setup showing only `set_level` behavior with `turn_on`/`turn_off` blocked, so you can adapt it. |

</details>
</tool-use>

---



---


üìó **Short answer:** You can't remove `turn_on` and `turn_off` (they're required), but you can make brightness-only changes go through `set_level`.

**How it works:**
- If `set_level` is defined, `light.turn_on` calls with only brightness (and optionally `transition`) use `set_level`, not `turn_on`.
- `turn_on` is still used when the call includes color, effect, or other parameters (or when there's no brightness).
- `turn_off` handles off commands.

**Options:**

### Option 1: Minimal `turn_on`/`turn_off`, rely on `set_level` for brightness

```yaml
template:
  - light:
      - name: "Living Room Main Light"
        unique_id: lr_main
        state: "{{ is_state('switch.knx_lr_light', 'on') }}"
        level: "{{ state_attr('light.lr_smart_bulb', 'brightness') | default(0) }}"
        turn_on:
          # Minimal - just ensure switch is on (brightness changes handled by set_level)
          - service: switch.turn_on
            target:
              entity_id: switch.knx_lr_light
        turn_off:
          - service: switch.turn_off
            target:
              entity_id: switch.knx_lr_light
        set_level:
          # This handles brightness-only changes
          - service: switch.turn_on
            target:
              entity_id: switch.knx_lr_light
          - delay: 0.3
          - service: light.turn_on
            target:
              entity_id: light.lr_smart_bulb
            data:
              brightness: "{{ brightness }}"
```

**Result:** Brightness-only calls use `set_level`. Pure `turn_on`/`turn_off` still need to exist.

### Option 2: Make `turn_on` a no-op if you want to ignore pure on/off

```yaml
turn_on:
  # No-op - brightness changes go to set_level anyway
  - service: homeassistant.update_entity
    target:
      entity_id: light.lr_main
```

**Trade-off:** Pure on/off commands won't do much, but brightness changes through `set_level` will work.

**Note:** The UI may still send `turn_on` without brightness for toggle actions. If you want to avoid that, handle it in the UI/card configuration or in automations.

Do you want `turn_on`/`turn_off` to do something minimal, or nothing at all?

---

_**User (2026-01-16 11:58Z)**_

when a scene turns on a smart bulb (z2m) with specific brightness level - in the hass scene editor ui the light is adjusted with desired brightness. does scene activation issue on + set_level or just set_level

---

_**Agent (model default, mode Ask)**_



---


Checking how Home Assistant scenes activate lights with brightness. Searching the codebase for scene examples and checking documentation.


---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** ‚Ä¢ Searched codebase "scene turn_on light brightness activation" ‚Ä¢ **15** results</summary>
            
| File | Lines |
|------|-------|
| `hass-config/automations.yaml` | L377-458 |
| `hass-config/blueprints/automation/homeassistant/motion_light.yaml` | L56 |
| `hass-config/automations.yaml` | L450-544 |
| `hass-config/automations.yaml` | L99-201 |
| `hass-config/automations.yaml` | L106 |
| `hass-config/scenes.yaml` | L665-722 |
| `hass-config/automations.yaml` | L195-287 |
| `hass-config/automations.yaml` | L281-380 |
| `hass-generator/src/generators/dashboard/templates/bubble/renderer.js` | L196-292 |
| `hass-config/scenes.yaml` | L993-1044 |
| `hass-config/packages/areas/lr_living_room.yaml` | L44 |
| `hass-config/scenes.yaml` | L54 |
| `hass-config/scenes.yaml` | L1039-1081 |
| `hass-config/scenes.yaml` | L199-254 |
| `hass-config/lovelace/main.yaml` | L697-751 |

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** ‚Ä¢ Grep for "scene\.turn_on|scene:" in "/Users/sharonfrenkel/Dev/hass-config" ‚Ä¢ 214 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `./lovelace/views-he.yaml` | `perform_action: scene.turn_on` | L117 |
| `./lovelace/views-he.yaml` | `perform_action: scene.turn_on` | L155 |
| `./lovelace/views-he.yaml` | `perform_action: scene.turn_on` | L197 |
| `./lovelace/views-he.yaml` | `perform_action: scene.turn_on` | L240 |
| `./lovelace/views-he.yaml` | `perform_action: scene.turn_on` | L280 |
| `./lovelace/views-he.yaml` | `perform_action: scene.turn_on` | L318 |
| `./lovelace/views-he.yaml` | `perform_action: scene.turn_on` | L353 |
| `./lovelace/views-he.yaml` | `perform_action: scene.turn_on` | L388 |
| `./lovelace/views-he.yaml` | `perform_action: scene.turn_on` | L423 |
| `./lovelace/views-he.yaml` | `perform_action: scene.turn_on` | L458 |
| `./lovelace/views-he.yaml` | `perform_action: scene.turn_on` | L482 |
| `./lovelace/views-he.yaml` | `perform_action: scene.turn_on` | L517 |
| `./lovelace/views-he.yaml` | `perform_action: scene.turn_on` | L555 |
| `./lovelace/views-he.yaml` | `perform_action: scene.turn_on` | L574 |
| `./lovelace/views-he.yaml` | `perform_action: scene.turn_on` | L593 |
| `./lovelace/views-he.yaml` | `perform_action: scene.turn_on` | L628 |
| `./lovelace/views-he.yaml` | `perform_action: scene.turn_on` | L647 |
| `./lovelace/views-he.yaml` | `perform_action: scene.turn_on` | L690 |
| `./lovelace/views-he.yaml` | `perform_action: scene.turn_on` | L869 |
| `./lovelace/views-he.yaml` | `perform_action: scene.turn_on` | L1061 |
| `./lovelace/views-he.yaml` | `perform_action: scene.turn_on` | L1233 |
| `./lovelace/views-he.yaml` | `perform_action: scene.turn_on` | L1408 |
| `./lovelace/views-he.yaml` | `perform_action: scene.turn_on` | L1542 |
| `./lovelace/views-he.yaml` | `perform_action: scene.turn_on` | L1659 |
| `./lovelace/views-he.yaml` | `perform_action: scene.turn_on` | L1757 |
| `./lovelace/views-he.yaml` | `perform_action: scene.turn_on` | L1855 |
| `./lovelace/views-he.yaml` | `perform_action: scene.turn_on` | L1922 |
| `./lovelace/views-he.yaml` | `perform_action: scene.turn_on` | L2024 |
| `./lovelace/views-he.yaml` | `perform_action: scene.turn_on` | L2109 |
| `./lovelace/views-he.yaml` | `perform_action: scene.turn_on` | L2218 |
| `./lovelace/views-he.yaml` | `perform_action: scene.turn_on` | L2304 |
| `./lovelace/views-he.yaml` | `perform_action: scene.turn_on` | L2374 |
| `./lovelace/views-he.yaml` | `perform_action: scene.turn_on` | L2464 |
| `./lovelace/views-he.yaml` | `perform_action: scene.turn_on` | L2589 |
| `./lovelace/views-en.yaml` | `perform_action: scene.turn_on` | L117 |
| `./lovelace/views-en.yaml` | `perform_action: scene.turn_on` | L155 |
| `./lovelace/views-en.yaml` | `perform_action: scene.turn_on` | L197 |
| `./lovelace/views-en.yaml` | `perform_action: scene.turn_on` | L240 |
| `./lovelace/views-en.yaml` | `perform_action: scene.turn_on` | L280 |
| `./lovelace/views-en.yaml` | `perform_action: scene.turn_on` | L318 |
| `./lovelace/views-en.yaml` | `perform_action: scene.turn_on` | L353 |
| `./lovelace/views-en.yaml` | `perform_action: scene.turn_on` | L388 |
| `./lovelace/views-en.yaml` | `perform_action: scene.turn_on` | L423 |
| `./lovelace/views-en.yaml` | `perform_action: scene.turn_on` | L458 |
| `./lovelace/views-en.yaml` | `perform_action: scene.turn_on` | L482 |
| `./lovelace/views-en.yaml` | `perform_action: scene.turn_on` | L517 |
| `./lovelace/views-en.yaml` | `perform_action: scene.turn_on` | L555 |
| `./lovelace/views-en.yaml` | `perform_action: scene.turn_on` | L574 |
| `./lovelace/views-en.yaml` | `perform_action: scene.turn_on` | L593 |
| `./lovelace/views-en.yaml` | `perform_action: scene.turn_on` | L628 |
| `./lovelace/views-en.yaml` | `perform_action: scene.turn_on` | L647 |
| `./lovelace/views-en.yaml` | `perform_action: scene.turn_on` | L690 |
| `./lovelace/views-en.yaml` | `perform_action: scene.turn_on` | L869 |
| `./lovelace/views-en.yaml` | `perform_action: scene.turn_on` | L1061 |
| `./lovelace/views-en.yaml` | `perform_action: scene.turn_on` | L1233 |
| `./lovelace/views-en.yaml` | `perform_action: scene.turn_on` | L1408 |
| `./lovelace/views-en.yaml` | `perform_action: scene.turn_on` | L1542 |
| `./lovelace/views-en.yaml` | `perform_action: scene.turn_on` | L1659 |
| `./lovelace/views-en.yaml` | `perform_action: scene.turn_on` | L1757 |
| `./lovelace/views-en.yaml` | `perform_action: scene.turn_on` | L1855 |
| `./lovelace/views-en.yaml` | `perform_action: scene.turn_on` | L1922 |
| `./lovelace/views-en.yaml` | `perform_action: scene.turn_on` | L2024 |
| `./lovelace/views-en.yaml` | `perform_action: scene.turn_on` | L2109 |
| `./lovelace/views-en.yaml` | `perform_action: scene.turn_on` | L2218 |
| `./lovelace/views-en.yaml` | `perform_action: scene.turn_on` | L2304 |
| `./lovelace/views-en.yaml` | `perform_action: scene.turn_on` | L2374 |
| `./lovelace/views-en.yaml` | `perform_action: scene.turn_on` | L2464 |
| `./lovelace/views-en.yaml` | `perform_action: scene.turn_on` | L2589 |
| `./lovelace/main.yaml` | `perform_action: scene.turn_on` | L17 |
| `./lovelace/main.yaml` | `perform_action: scene.turn_on` | L55 |
| `./lovelace/main.yaml` | `perform_action: scene.turn_on` | L97 |
| `./lovelace/main.yaml` | `perform_action: scene.turn_on` | L140 |
| `./lovelace/main.yaml` | `perform_action: scene.turn_on` | L180 |
| `./lovelace/main.yaml` | `perform_action: scene.turn_on` | L218 |
| `./lovelace/main.yaml` | `perform_action: scene.turn_on` | L253 |
| `./lovelace/main.yaml` | `perform_action: scene.turn_on` | L288 |
| `./lovelace/main.yaml` | `perform_action: scene.turn_on` | L323 |
| `./lovelace/main.yaml` | `perform_action: scene.turn_on` | L358 |
| `./lovelace/main.yaml` | `perform_action: scene.turn_on` | L382 |
| `./lovelace/main.yaml` | `perform_action: scene.turn_on` | L417 |
| `./lovelace/main.yaml` | `perform_action: scene.turn_on` | L455 |
| `./lovelace/main.yaml` | `perform_action: scene.turn_on` | L474 |
| `./lovelace/main.yaml` | `perform_action: scene.turn_on` | L493 |
| `./lovelace/main.yaml` | `perform_action: scene.turn_on` | L528 |
| `./lovelace/main.yaml` | `perform_action: scene.turn_on` | L547 |
| `./lovelace/main.yaml` | `perform_action: scene.turn_on` | L587 |
| `./lovelace/main.yaml` | `perform_action: scene.turn_on` | L747 |
| `./lovelace/main.yaml` | `perform_action: scene.turn_on` | L925 |
| `./lovelace/main.yaml` | `perform_action: scene.turn_on` | L1080 |
| `./lovelace/main.yaml` | `perform_action: scene.turn_on` | L1238 |
| `./lovelace/main.yaml` | `perform_action: scene.turn_on` | L1350 |
| `./lovelace/main.yaml` | `perform_action: scene.turn_on` | L1448 |
| `./lovelace/main.yaml` | `perform_action: scene.turn_on` | L1527 |
| `./lovelace/main.yaml` | `perform_action: scene.turn_on` | L1606 |
| `./lovelace/main.yaml` | `perform_action: scene.turn_on` | L1654 |
| `./lovelace/main.yaml` | `perform_action: scene.turn_on` | L1742 |
| `./lovelace/main.yaml` | `perform_action: scene.turn_on` | L1805 |
| `./lovelace/main.yaml` | `perform_action: scene.turn_on` | L1895 |
| `./lovelace/main.yaml` | `perform_action: scene.turn_on` | L1962 |
| `./lovelace/main.yaml` | `perform_action: scene.turn_on` | L2013 |
| `./lovelace/main.yaml` | `perform_action: scene.turn_on` | L2084 |
| `./lovelace/main.yaml` | `perform_action: scene.turn_on` | L2190 |
| `./packages/areas/br2_tom_s_bedroom.yaml` | `br2_active_scene:` | L15 |
| `./packages/areas/ssol_studio_solaris.yaml` | `ssol_active_scene:` | L12 |
| `./packages/areas/stdn_sharon_s_studio.yaml` | `stdn_active_scene:` | L18 |
| `./packages/areas/stdr_shahar_s_studio.yaml` | `stdr_active_scene:` | L20 |
| `./packages/areas/ptio_front_yard.yaml` | `ptio_active_scene:` | L18 |
| `./packages/areas/ofc_office.yaml` | `ofc_active_scene:` | L15 |
| `./packages/areas/mwc_parent_s_wc.yaml` | `mwc_active_scene:` | L17 |
| `./packages/areas/mb_bedroom.yaml` | `mb_active_scene:` | L16 |
| `./packages/areas/mmd_mamad.yaml` | `mmd_active_scene:` | L6 |
| `./packages/areas/lr_living_room.yaml` | `lr_active_scene:` | L19 |
| `./packages/areas/lndr_laundry_room.yaml` | `lndr_active_scene:` | L12 |
| `./packages/areas/ksol_kitchen_solaris.yaml` | `ksol_active_scene:` | L13 |
| `./packages/areas/kt_kitchen.yaml` | `kt_active_scene:` | L18 |
| `./packages/areas/hacs_home_assistant.yaml` | `hacs_active_scene:` | L6 |
| `./packages/areas/is_home.yaml` | `is_active_scene:` | L6 |
| `./packages/areas/crd_corridor.yaml` | `crd_active_scene:` | L13 |
| `./packages/areas/cwc_children_s_wc.yaml` | `cwc_active_scene:` | L15 |
| `./packages/areas/br1_amai_s_room.yaml` | `br1_active_scene:` | L15 |
| `./packages.backup/areas/stdr_shahar_s_studio.yaml` | `stdr_active_scene:` | L20 |
| `./packages.backup/areas/stdn_sharon_s_studio.yaml` | `stdn_active_scene:` | L18 |
| `./packages.backup/areas/ssol_studio_solaris.yaml` | `ssol_active_scene:` | L12 |
| `./packages.backup/areas/ptio_front_yard.yaml` | `ptio_active_scene:` | L18 |
| `./packages.backup/areas/ofc_office.yaml` | `ofc_active_scene:` | L15 |
| `./packages.backup/areas/mwc_parent_s_wc.yaml` | `mwc_active_scene:` | L17 |
| `./packages.backup/areas/mmd_mamad.yaml` | `mmd_active_scene:` | L6 |
| `./packages.backup/areas/mb_bedroom.yaml` | `mb_active_scene:` | L16 |
| `./packages.backup/areas/lr_living_room.yaml` | `lr_active_scene:` | L19 |
| `./packages.backup/areas/lndr_laundry_room.yaml` | `lndr_active_scene:` | L12 |
| `./packages.backup/areas/kt_kitchen.yaml` | `kt_active_scene:` | L18 |
| `./packages.backup/areas/ksol_kitchen_solaris.yaml` | `ksol_active_scene:` | L13 |
| `./packages.backup/areas/is_home.yaml` | `is_active_scene:` | L6 |
| `./packages.backup/areas/home_home.yaml` | `home_active_scene:` | L6 |
| `./packages.backup/areas/hacs_home_assistant.yaml` | `hacs_active_scene:` | L6 |
| `./packages.backup/areas/cwc_children_s_wc.yaml` | `cwc_active_scene:` | L15 |
| `./packages.backup/areas/crd_corridor.yaml` | `crd_active_scene:` | L13 |
| `./packages.backup/areas/corridor_corridor.yaml` | `corridor_active_scene:` | L13 |
| `./packages.backup/areas/br2_tom_s_bedroom.yaml` | `br2_active_scene:` | L15 |
| `./packages.backup/areas/br1_amai_s_room.yaml` | `br1_active_scene:` | L15 |
| `./lovelace.backup/views.yaml` | `perform_action: scene.turn_on` | L117 |
| `./lovelace.backup/views.yaml` | `perform_action: scene.turn_on` | L155 |
| `./lovelace.backup/views.yaml` | `perform_action: scene.turn_on` | L197 |
| `./lovelace.backup/views.yaml` | `perform_action: scene.turn_on` | L240 |
| `./lovelace.backup/views.yaml` | `perform_action: scene.turn_on` | L280 |
| `./lovelace.backup/views.yaml` | `perform_action: scene.turn_on` | L318 |
| `./lovelace.backup/views.yaml` | `perform_action: scene.turn_on` | L353 |
| `./lovelace.backup/views.yaml` | `perform_action: scene.turn_on` | L388 |
| `./lovelace.backup/views.yaml` | `perform_action: scene.turn_on` | L423 |
| `./lovelace.backup/views.yaml` | `perform_action: scene.turn_on` | L458 |
| `./lovelace.backup/views.yaml` | `perform_action: scene.turn_on` | L482 |
| `./lovelace.backup/views.yaml` | `perform_action: scene.turn_on` | L517 |
| `./lovelace.backup/views.yaml` | `perform_action: scene.turn_on` | L555 |
| `./lovelace.backup/views.yaml` | `perform_action: scene.turn_on` | L574 |
| `./lovelace.backup/views.yaml` | `perform_action: scene.turn_on` | L593 |
| `./lovelace.backup/views.yaml` | `perform_action: scene.turn_on` | L628 |
| `./lovelace.backup/views.yaml` | `perform_action: scene.turn_on` | L647 |
| `./lovelace.backup/views.yaml` | `perform_action: scene.turn_on` | L690 |
| `./lovelace.backup/views.yaml` | `perform_action: scene.turn_on` | L869 |
| `./lovelace.backup/views.yaml` | `perform_action: scene.turn_on` | L1061 |
| `./lovelace.backup/views.yaml` | `perform_action: scene.turn_on` | L1233 |
| `./lovelace.backup/views.yaml` | `perform_action: scene.turn_on` | L1408 |
| `./lovelace.backup/views.yaml` | `perform_action: scene.turn_on` | L1542 |
| `./lovelace.backup/views.yaml` | `perform_action: scene.turn_on` | L1659 |
| `./lovelace.backup/views.yaml` | `perform_action: scene.turn_on` | L1757 |
| `./lovelace.backup/views.yaml` | `perform_action: scene.turn_on` | L1855 |
| `./lovelace.backup/views.yaml` | `perform_action: scene.turn_on` | L1922 |
| `./lovelace.backup/views.yaml` | `perform_action: scene.turn_on` | L2024 |
| `./lovelace.backup/views.yaml` | `perform_action: scene.turn_on` | L2109 |
| `./lovelace.backup/views.yaml` | `perform_action: scene.turn_on` | L2218 |
| `./lovelace.backup/views.yaml` | `perform_action: scene.turn_on` | L2304 |
| `./lovelace.backup/views.yaml` | `perform_action: scene.turn_on` | L2374 |
| `./lovelace.backup/views.yaml` | `perform_action: scene.turn_on` | L2464 |
| `./lovelace.backup/views.yaml` | `perform_action: scene.turn_on` | L2589 |
| `./lovelace.backup/main.yaml` | `perform_action: scene.turn_on` | L17 |
| `./lovelace.backup/main.yaml` | `perform_action: scene.turn_on` | L55 |
| `./lovelace.backup/main.yaml` | `perform_action: scene.turn_on` | L97 |
| `./lovelace.backup/main.yaml` | `perform_action: scene.turn_on` | L140 |
| `./lovelace.backup/main.yaml` | `perform_action: scene.turn_on` | L180 |
| `./lovelace.backup/main.yaml` | `perform_action: scene.turn_on` | L218 |
| `./lovelace.backup/main.yaml` | `perform_action: scene.turn_on` | L253 |
| `./lovelace.backup/main.yaml` | `perform_action: scene.turn_on` | L288 |
| `./lovelace.backup/main.yaml` | `perform_action: scene.turn_on` | L323 |
| `./lovelace.backup/main.yaml` | `perform_action: scene.turn_on` | L358 |
| `./lovelace.backup/main.yaml` | `perform_action: scene.turn_on` | L382 |
| `./lovelace.backup/main.yaml` | `perform_action: scene.turn_on` | L417 |
| `./lovelace.backup/main.yaml` | `perform_action: scene.turn_on` | L455 |
| `./lovelace.backup/main.yaml` | `perform_action: scene.turn_on` | L474 |
| `./lovelace.backup/main.yaml` | `perform_action: scene.turn_on` | L493 |
| `./lovelace.backup/main.yaml` | `perform_action: scene.turn_on` | L528 |
| `./lovelace.backup/main.yaml` | `perform_action: scene.turn_on` | L547 |
| `./lovelace.backup/main.yaml` | `perform_action: scene.turn_on` | L587 |
| `./lovelace.backup/main.yaml` | `perform_action: scene.turn_on` | L747 |
| `./lovelace.backup/main.yaml` | `perform_action: scene.turn_on` | L925 |
| `./lovelace.backup/main.yaml` | `perform_action: scene.turn_on` | L1080 |
| `./lovelace.backup/main.yaml` | `perform_action: scene.turn_on` | L1238 |
| `./lovelace.backup/main.yaml` | `perform_action: scene.turn_on` | L1350 |
| `./lovelace.backup/main.yaml` | `perform_action: scene.turn_on` | L1448 |
| `./lovelace.backup/main.yaml` | `perform_action: scene.turn_on` | L1527 |
| `./lovelace.backup/main.yaml` | `perform_action: scene.turn_on` | L1606 |
| `./lovelace.backup/main.yaml` | `perform_action: scene.turn_on` | L1654 |
| `./lovelace.backup/main.yaml` | `perform_action: scene.turn_on` | L1742 |
| `./lovelace.backup/main.yaml` | `perform_action: scene.turn_on` | L1805 |
| `./lovelace.backup/main.yaml` | `perform_action: scene.turn_on` | L1895 |
| `./lovelace.backup/main.yaml` | `perform_action: scene.turn_on` | L1962 |
| `./lovelace.backup/main.yaml` | `perform_action: scene.turn_on` | L2013 |
| `./lovelace.backup/main.yaml` | `perform_action: scene.turn_on` | L2084 |
| `./lovelace.backup/main.yaml` | `perform_action: scene.turn_on` | L2190 |
| `./automations.yaml` | `- action: scene.turn_on` | L115 |
| `./automations.yaml` | `- action: scene.turn_on` | L149 |
| `./automations.yaml` | `- action: scene.turn_on` | L429 |
| `./automations.yaml` | `- action: scene.turn_on` | L538 |
| `./packages/areas/home_home.yaml` | `home_active_scene:` | L6 |
| `./packages/areas/corridor_corridor.yaml` | `corridor_active_scene:` | L13 |


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** ‚Ä¢ Read file: /Users/sharonfrenkel/Dev/hass-config/scenes.yaml</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="web_search">
<details>
            <summary>Tool use: **web_search** ‚Ä¢ Searched web `Home Assistant scene activation light brightness service call turn_on set_level` ‚Ä¢ **1** results</summary>
        
| Title | URL | Chunk |
|-------|-----|-------|
| Web Search Results |  | When a scene activates a light (including via the UI or via `scene.turn_on`) and that scene includes a brightness setting, here's what happens under the hood & how it behaves, especially for **template lights** in Home Assistant:<br/><br/>---<br/><br/>### How scenes issue commands under the hood<br/><br/>- A scene stores desired states for entities. For lights, that often includes `state: "on"` *plus* optional attributes like `brightness`, `color_temp`, etc. ([home-assistant.io](https://www.home-assistant.io/docs/scene/?utm_source=openai))  <br/>- When you activate the scene (via `scene.turn_on`), HA takes those stored states and attributes and issues service calls to each light. For lights with brightness in the scene definition, the service call will typically be `light.turn_on` with a `brightness` attribute. ([home-assistant.io](https://www.home-assistant.io/integrations/scene/?utm_source=openai))<br/><br/>---<br/><br/>### Interactions with Template Lights: `set_level` vs `turn_on`<br/><br/>Template lights offer a more complex behavior:<br/><br/>- They define multiple action types, including `turn_on`, `turn_off`, **and** an optional `set_level` for handling brightness-only adjustments. ([home-assistant.io](https://www.home-assistant.io/integrations/template/?utm_source=openai))  <br/>- If a `light.turn_on` call includes only `brightness` (and maybe `transition`), *and* `set_level` is defined, then HA will use the `set_level` action. But if `turn_on` is called with brightness *and* some other attribute (e.g., color temperature), or the scene sets the light from off to on, then `turn_on` is used, with brightness passed in. ([home-assistant.io](https://www.home-assistant.io/integrations/template/?utm_source=openai))<br/><br/>---<br/><br/>### Scene activation with a template light setting brightness<br/><br/>Putting those pieces together, when your scene includes `brightness: XYZ`, here‚Äôs what usually happens with a template light:<br/><br/>1. The scene definition has state ‚Äúon‚Äù and brightness value (since brightness in a scene implies turning ‚Äúon‚Äù if the light was off) ([home-assistant.io](https://www.home-assistant.io/docs/scene/?utm_source=openai))  <br/>2. Activating the scene causes HA to send a `light.turn_on` for that entity with `brightness: XYZ`.  <br/>3. Since there‚Äôs more than just brightness (the state is turning it on), HA **opts for** the `turn_on` action in your template light configuration, not `set_level`. `set_level` only takes effect when **only** brightness is passed (i.e. brightness change while already ‚Äúon‚Äù) without other parameters. ([home-assistant.io](https://www.home-assistant.io/integrations/template/?utm_source=openai))<br/><br/>---<br/><br/>### Short answer to your question<br/><br/>> When a scene turns on a smart bulb (via Zigbee2MQTT) with a specific brightness level ‚Ä¶ does the activation issue `on + set_level`, or just `set_level`?<br/><br/>- It issues **`turn_on`** with brightness (and possibly other attributes, like transition), not `set_level`, because in that context the light is being turned on (from ‚Äúoff‚Äù state).  <br/>- `set_level` would only be used if the scene (or other service call) *only* changes brightness while the light is already on, and `set_level` is defined on the template light.  <br/><br/>---<br/><br/>If you want a scene to *only change brightness* (not turn the light on if it‚Äôs off), you could use automations or service calls that check `light.is_on` first and then call `light.turn_on` or `light.turn_on` with brightness only. But scenes by design include state, so they always manage both state + attributes.<br/><br/>If you want help adjusting your template light to handle brightness-only updates more cleanly, I can show you how to set that up. |

</details>
</tool-use>

---



---


Reviewing scene structure in the codebase:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** ‚Ä¢ Read file: /Users/sharonfrenkel/Dev/hass-config/scenes.yaml</summary>

</details>
</tool-use>

---



---


Scene activation calls `turn_on` with brightness, not `set_level`.

**How scenes work:**
Scenes store both `state: true` and attributes like `brightness`. For example:
```yaml
light.mb_soc_bulb:
  state: true           # ‚Üê State is "on"
  brightness: 222       # ‚Üê Brightness attribute
  color_mode: brightness
```

**When the scene activates:**
1. Home Assistant calls `light.turn_on` with all attributes (brightness, color_temp, etc.), not just brightness.
2. For template lights, `set_level` is only used when `light.turn_on` is called with only brightness (and optionally `transition`), with no other attributes.
3. Since scenes include state + attributes, `turn_on` is used, not `set_level`.

**Practical impact for your template light:**
- Scene activation ‚Üí uses `turn_on` action (brightness is available as `{{ brightness }}` in `turn_on`).
- Brightness-only change while already on ‚Üí uses `set_level` (if defined).

**Summary:**
- Scene activation: `turn_on` with brightness (and other attributes).
- Brightness-only while on: `set_level` (if the call is brightness-only).

If you want scenes to use `set_level`, that‚Äôs not how scenes work‚Äîthey always include state, so they trigger `turn_on`.

---

_**User (2026-01-16 11:58Z)**_

in the template, a provision is made for when the scene is triggered when the bulb power is off. first, the power needs to be turned on, the bulb then boots which takes a while so a delay is placed and then set_level. but you said that the scene triggers on with brightness - so set_level with the delay wont run...?

---

_**Agent (model default, mode Ask)**_



---


Since scenes use `turn_on` (not `set_level`), `set_level` won't run when a scene activates the light from off. The delay/boot sequence should be in `turn_on` as well.

For a template light with brightness:
- Scene activation (state change + brightness) ‚Üí `turn_on`
- Brightness-only change (while on) ‚Üí `set_level`

Solution: duplicate the boot delay logic in `turn_on` so it runs on scene activation:

```yaml
template:
  - light:
      - name: "Living Room Main Light"
        unique_id: lr_main
        state: "{{ is_state('switch.knx_lr_light', 'on') }}"
        level: "{{ state_attr('light.lr_smart_bulb', 'brightness') | default(0) }}"
        turn_on:
          # Handle scene activation: power on, wait for boot, then set brightness
          - service: switch.turn_on
            target:
              entity_id: switch.knx_lr_light
          - delay: 0.3  # Wait for bulb to boot
          - service: light.turn_on
            target:
              entity_id: light.lr_smart_bulb
            data:
              brightness: "{{ brightness | default(255) }}"  # Use brightness if provided, else default
        turn_off:
          - service: switch.turn_off
            target:
              entity_id: switch.knx_lr_light
        set_level:
          # Handle brightness changes while already on
          - service: switch.turn_on
            target:
              entity_id: switch.knx_lr_light
          - delay: 0.3
          - service: light.turn_on
            target:
              entity_id: light.lr_smart_bulb
            data:
              brightness: "{{ brightness }}"
```

Key points:
1. `turn_on` handles scene activation and includes the boot delay and brightness setting.
2. `set_level` handles brightness changes when already on.
3. Both actions turn on the switch first (in case it's off), wait for boot, then set brightness.

This ensures the delay runs whether the light is activated via scene (`turn_on`) or via a brightness-only change (`set_level`).

---

_**User (2026-01-16 23:31Z)**_

it was proposed that i use a template for pairing power switches to dimmable smart bulbs so that scenes can affect brightness when inital state is power=off. the tmplate whould wait for the bulb to join the mesh before adjusting brightness. this is also true for temprature, color, etc when the bulb supports these. could this be done with an automation instead of a template. if so, pros and cons of each method

---

_**Agent (model default, mode Ask)**_



---

Searching the codebase for automation examples handling similar scenarios:


---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** ‚Ä¢ Searched codebase "automation smart bulb power switch turn on wait delay brightness" ‚Ä¢ **15** results</summary>
            
| File | Lines |
|------|-------|
| `hass-config/blueprints/automation/homeassistant/motion_light.yaml` | L56 |
| `hass-config/automations.yaml` | L106 |
| `hass-config/automations.yaml` | L195-287 |
| `hass-config/automations.yaml` | L377-458 |
| `hass-config/automations.yaml` | L281-380 |
| `hass-config/automations.yaml` | L450-544 |
| `hass-generator/src/generators/dashboard/templates/bubble/renderer.js` | L196-292 |
| `hass-config/packages/climate_persistence.yaml` | L44 |
| `hass-config/automations.yaml` | L99-201 |
| `hass-generator/src/generators/dashboard/templates/bubble-views/renderer.js` | L316-406 |
| `hass-config/packages/areas/ofc_office.yaml` | L36 |
| `hass-config/knx/knx.yaml` | L210-329 |
| `hass-config/scenes.yaml` | L1039-1081 |
| `hass-config/lovelace/main.yaml` | L958-1005 |
| `hass-config/generator.config.js` | L68 |

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** ‚Ä¢ Read file: /Users/sharonfrenkel/Dev/hass-config/automations.yaml</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="web_search">
<details>
            <summary>Tool use: **web_search** ‚Ä¢ Searched web `Home Assistant template light vs automation smart bulb power switch dimming scene activation` ‚Ä¢ **1** results</summary>
        
| Title | URL | Chunk |
|-------|-----|-------|
| Web Search Results |  | Yes ‚Äî you *can* implement your idea with either a template light or an automation in Home Assistant. Each approach has trade-offs. Below are comparisons of how well each fits your use-case (handling when scenes turn on bulbs that were off, boot delay, brightness/color attributes), and pros & cons to help you choose.<br/><br/>---<br/><br/>## What you need to do<br/><br/>Your goal: When a scene is activated and the smart bulb is currently powered off, you need to:<br/><br/>1. Detect that it's off.<br/>2. Turn it on (power) ‚Äî which causes a boot delay since Z2M bulbs need some milliseconds to start up.<br/>3. After boot (wait/delay), set brightness (and/or color, temperature, etc.) per the scene‚Äôs settings.<br/><br/>You want that to happen for scenes (which call `light.turn_on` with `brightness` etc.), and also any caller that uses `set_level` or other attribute changes when the light is already on.<br/><br/>---<br/><br/>## Template Light vs Automation<br/><br/>Here‚Äôs how each manages those steps:<br/><br/>\| Feature \| Template Light \| Automation \|<br/>\|---\|---\|---\|<br/>\| Can intercept **all** ways the light is turned on (scene, manual UI, automation) \| Yes ‚Äî since template light wraps the `turn_on`, `turn_off`, `set_level`, etc. in your defined actions; you can centralize behavior like ‚Äúif off, turn on, delay, then set attributes‚Äù. ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai)) \| Partial ‚Äî automation must be triggered on specific events (scene activation, light turned on, etc.). It may miss direct UI or manual app control unless you explicitly cover those triggers. \|<br/>\| Handling ‚Äúboot delay‚Äù after power off \| Can embed delay logic inside the template‚Äôs `turn_on` script/template part. Since every `turn_on` (from scene/UI/etc) invokes your template action, that delay will happen whenever needed. \| You can use an automation triggered when light goes from ‚Äúoff‚Äù to ‚Äúon‚Äù AND perhaps some condition that attributes haven‚Äôt been set. But that introduces more triggers/conditions and possible race timing issues. \|<br/>\| Handling brightness, color, temperature, etc. attributes \| Template light supports passing variables like `brightness`, `color_temp`, `rgb_color`, etc., into the templates/actions. If only brightness present, there's a ‚Äúset_level‚Äù action; if brightness + other attributes, they are passed accordingly. ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai)) \| Automation could set all attributes, but you need to fetch the scene‚Äôs state or include the attributes in the trigger or actions; you‚Äôd need perhaps snapshotting or reading the desired state. More complex. \|<br/>\| Scene vs other calls consistency \| Uniform ‚Äî all paths go through the template‚Äôs logic. \| Risk of divergence: some paths (UI, Lovelace, voice assistant) may trigger `light.turn_on` or set brightness directly, bypassing automation if not carefully triggered. \|<br/><br/>---<br/><br/>## Pros and Cons<br/><br/>### Using a **Template Light**<br/><br/>**Pros:**<br/><br/>- Central control: You define once how the light should behave whenever it‚Äôs turned on, etc. Less duplication and fewer places to maintain logic.<br/>- Ensures boot delay logic always runs when bulb is off and `turn_on` is called (including scenes).<br/>- Cleaner for per-entity custom behavior (brightness/color) without needing multiple automations per scenario.<br/>- Easier to maintain consistency across different ways the light is controlled.<br/><br/>**Cons:**<br/><br/>- More complex initial setup: writing the template, action scripts, handling all possible parameters (brightness, color, effect, transitions, etc.).<br/>- Template light may add a small moment of delay even when not needed; if the light is already on and you just want to adjust brightness, you have to conditionally skip things.<br/>- Potential with ‚Äúoptimistic‚Äù behavior: template should reflect real state, else UI might show a state before the device actually takes it. In cases when device takes time to respond, you may need to handle state feedback. (Templates can work optimistic or wait for actual device feedback.) ([home-assistant.io](https://www.home-assistant.io/integrations/light.template/?utm_source=openai))<br/><br/>### Using **Automation(s)**<br/><br/>**Pros:**<br/><br/>- Simpler to write for specific trigger-based behavior (e.g. ‚Äúscene turned on‚Äù or ‚Äúlight changed from off to on‚Äù).<br/>- Flexible to handle multiple lights/entities in bulk without individually templating each one.<br/>- Easier to reuse or apply generic logic across many lights if patterns are similar.<br/><br/>**Cons:**<br/><br/>- Harder to cover all triggering paths: scenes, manual control, UI, voice, etc. If you miss a trigger, behavior may not happen.<br/>- More fragile timing: the automation may run before device is fully ‚Äúon‚Äù so setting brightness/color might fail or be ignored. You‚Äôd need delay or `wait_template` to guard. That complicates the automation YAML/scripts.<br/>- Duplication: if multiple lights or multiple scenes, you may need multiple automations or templated automations.<br/>- Harder to ensure that setting attributes always follow boot delay, especially when the ‚Äúdevice off ‚Üí scene‚Äù case happens.<br/><br/>---<br/><br/>## Real-world behavior with Scenes<br/><br/>According to Home Assistant scenes documentation:<br/><br/>- Scenes store entities with their desired **state** (on/off) and optionally **attributes** like `brightness`, `color_temp`, etc. ([home-assistant.io](https://www.home-assistant.io/integrations/scene/?utm_source=openai))  <br/>- When you call `scene.turn_on`, Home Assistant essentially issues `light.turn_on` (for lights), with `state: "on"` and any specified attributes. ([home-assistant.io](https://www.home-assistant.io/integrations/scene/?utm_source=openai))  <br/>- That means scene activation *already* uses `turn_on` with brightness etc., not `set_level`. If the light was off, the `turn_on` aspect is used. Thus in your template scenario, your `turn_on` action would run (with any attributes) during scene activation.<br/><br/>Given that, if your template light is implemented with smart logic in `turn_on` (checking if off, delaying if off, then applying brightness etc.), you can catch the scene-on case. Using an automation based solely on `set_level` won't catch scene activation when bulb is off, because scenes use `turn_on` not `set_level`.<br/><br/>Also, there are community reports about scenes turning lights on at full brightness briefly, then transitioning to desired brightness (especially if attributes are not sent atomically or due to hardware quirks) ‚Äî something a template or automation with proper delay/condition might help reduce. ([community.home-assistant.io](https://community.home-assistant.io/t/scene-activation-turns-on-lights-with-attributes-not-specified-in-scene/463068?utm_source=openai))<br/><br/>---<br/><br/>## Suggested approach for your use case<br/><br/>Given what you want (‚Äúboot delay when off, always get brightness/color etc.‚Äù), a template light **seems more robust**. Here‚Äôs a sketch of how you'd implement:<br/><br/>```yaml<br/>template:<br/>  - light:<br/>      - name: ‚ÄúSmart Bulb with Boot Delay‚Äù<br/>        state: ><br/>          \{% if is_state('light.my_bulb_real', 'on') %\}<br/>            on<br/>          \{% else %\}<br/>            off<br/>          \{% endif %\}<br/>        turn_on:<br/>          action:<br/>            - choose:<br/>                - conditions:<br/>                    - condition: state<br/>                      entity_id: light.my_bulb_real<br/>                      state: 'off'<br/>                  sequence:<br/>                    - service: light.turn_on<br/>                      target: entity_id: light.my_bulb_real<br/>                    - delay: '00:00:02'    # adjust boot time<br/>            - service: light.turn_on<br/>              target: entity_id: light.my_bulb_real<br/>              data: ><br/>                \{%- set b = brightness if brightness is defined else none -%\}<br/>                \{%- set ct = color_temp if color_temp is defined else none -%\}<br/>                \{%- set col = rgb_color if rgb_color is defined else none -%\}<br/>                \{%- set d = \{} -%\}<br/>                \{%- if b is not none %\} \{% set _ = d.update(\{'brightness': b\}) %\} \{% endif %\}<br/>                \{%- if ct is not none %\} \{% set _ = d.update(\{'color_temp': ct\}) %\} \{% endif %\}<br/>                \{%- if col is not none %\} \{% set _ = d.update(\{'rgb_color': col\}) %\} \{% endif %\}<br/>                \{{ d \}}<br/>        turn_off:<br/>          action:<br/>            service: light.turn_off<br/>            target: entity_id: light.my_bulb_real<br/>```<br/><br/>With this, any `turn_on` (scene, UI, automation) will follow the logic: if bulb was fully off, first send a plain `turn_on` (just power), wait for boot, then send brightness/color.<br/><br/>---<br/><br/>## When Automation might still make sense<br/><br/>You might prefer an automation if:<br/><br/>- You only care about certain scenes or times and don‚Äôt want that delay logic on *every* turn-on.<br/>- The number of lights/entities is large, and duplicating template config is burdensome.<br/>- Some bulbs don‚Äôt support color or brightness attributes; you can manage exceptions in automation more easily.<br/>- You already have automations in place and you don‚Äôt want to refactor into templates.<br/><br/>In that case, you would set up an automation like:<br/><br/>- **Trigger**: `scene.turn_on` service call (or maybe use `event` trigger for `call_service` where domain=scene and entity_id = your scene) or ‚Äúlight changed from off ‚Üí on‚Äù.<br/>- **Condition**: check the bulb is off.<br/>- **Actions**:<br/>  1. Turn on bulb (power).<br/>  2. `delay` for boot time.<br/>  3. Apply brightness/color via `light.turn_on` with desired attributes.  <br/><br/>This duplication and risk of missing triggers or timing issues are the cons.<br/><br/>---<br/><br/>## Summary<br/><br/>- If you want consistent behavior irrespective of *how* the light is turned on (scenes, UI, script, voice), a **template light** is cleaner and more reliable.  <br/>- If you're okay managing individual cases, or only care about scenes, an **automation** might be simpler initially but more fragile in covering edge cases.  <br/><br/>If you want, I can help you write both versions (template & automation) specifically for your bulb + scenes + delays, so you can compare and pick. |

</details>
</tool-use>

---



---

üìó Comparison for pairing power switches with dimmable smart bulbs, including boot delay:

## Template light vs automation

### Template light approach

**Pros:**
- Catches all activation paths: scenes, UI controls, voice, automations, scripts.
- Centralized logic: one definition handles power on, boot delay, brightness/color/temp.
- Scene-friendly: scenes use `turn_on`, which your template intercepts.
- State consistency: template reflects real state while hiding boot complexity.
- Supports all attributes: brightness, color_temp, rgb_color, etc. from template variables.

**Cons:**
- Setup complexity: requires handling `turn_on`, `turn_off`, and optionally `set_level` for each light.
- Potential delay even when not needed: requires conditional logic if boot delay isn‚Äôt always required.
- Per-entity configuration: needs a template entry for each switch/bulb pair.

### Automation approach

**How it would work:**
You'd need automations triggered by:
- Scene activation (event-based or state-based)
- Light entity state changes
- Possibly direct service calls

**Pros:**
- Simpler initial logic: clear triggers and actions.
- Bulk handling: can cover multiple lights with templates or scripts.
- Flexible conditions: can add checks (time, occupancy, etc.).
- Easier debugging: automation history shows clear trigger/action flow.

**Cons:**
- Coverage gaps: manual UI/app control or voice may bypass automations unless explicitly handled.
- Timing complexity: must handle boot delays and race conditions (e.g., scene setting brightness before boot completes).
- Scene challenge: scenes don't trigger a "scene activated" event; you'd need:
  - Event trigger on `call_service` with domain `scene`
  - Or state-based triggers on light entities (more brittle)
- Multiple automations needed: per-light, per-scene, or complex conditional logic.
- Attribute handling: must read scene state or pass attributes through other means.

**Example automation approach:**

```yaml
# Would need multiple automations like this:
- id: 'bulb_boot_delay_on_scene'
  alias: 'Smart Bulb Boot Delay on Scene'
  trigger:
    - platform: event
      event_type: call_service
      event_data:
        domain: scene
        service: turn_on
  condition:
    - condition: state
      entity_id: light.lr_smart_bulb
      state: 'off'
  action:
    - service: switch.turn_on
      target:
        entity_id: switch.knx_lr_light
    - delay: '00:00:00.3'
    # Problem: How do you know what brightness/color the scene wanted?
    # You'd need to check the scene state or store it somehow
```

## Recommendation

For your use case (scenes setting brightness/color/temp when power is off), use a template light:
1. Scenes always trigger `turn_on` on template lights, so you can intercept it.
2. Boot delay logic can be centralized in `turn_on`.
3. Works for UI, voice, and other control methods.
4. Supports brightness, color, temperature, etc. via template variables.

**When automation might make sense:**
- You only care about specific scenes (fewer edge cases).
- You have many lights and want a generic helper script.
- You want per-light conditions (time of day, occupancy).
- You already have a complex automation setup.

**Hybrid approach:**
Use template lights for the switch/bulb pairs, and optional automations for higher-level behavior (e.g., scene selection based on time/conditions).

Should I show a complete template light configuration that handles boot delay and all attributes (brightness, color_temp, rgb_color)?

---

